# coding: utf-8

"""
    Jarvice API

    The JARVICE API allows full control on running jobs as well as managing applications via PushToComputeâ„¢.  # noqa: E501

    The version of the OpenAPI document: 1.0
    Contact: support@nimbix.net
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictBool, StrictInt, StrictStr

from typing import Any, Dict, List, Optional, Union

from openapi_client.models.app_def import AppDef
from openapi_client.models.job_entry import JobEntry
from openapi_client.models.queue import Queue
from openapi_client.models.runtime_connect import RuntimeConnect
from openapi_client.models.runtime_metrics import RuntimeMetrics
from openapi_client.models.sched_job_status_entry import SchedJobStatusEntry
from openapi_client.models.team_user import TeamUser

from openapi_client.api_client import ApiClient
from openapi_client.api_response import ApiResponse
from openapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class StatusAndInformationApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def appdef_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[StrictStr, Field(..., description="Name of application to return information for; please note this is the application ID, not necessarily the same as the name value in the AppDef")], **kwargs) -> AppDef:  # noqa: E501
        """Returns the Application Definition (AppDef) for a given application.  # noqa: E501

        Returns the Application Definition (AppDef) for a given application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.appdef_get(apikey, username, name, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Name of application to return information for; please note this is the application ID, not necessarily the same as the name value in the AppDef (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: AppDef
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the appdef_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.appdef_get_with_http_info(apikey, username, name, **kwargs)  # noqa: E501

    @validate_arguments
    def appdef_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[StrictStr, Field(..., description="Name of application to return information for; please note this is the application ID, not necessarily the same as the name value in the AppDef")], **kwargs) -> ApiResponse:  # noqa: E501
        """Returns the Application Definition (AppDef) for a given application.  # noqa: E501

        Returns the Application Definition (AppDef) for a given application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.appdef_get_with_http_info(apikey, username, name, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Name of application to return information for; please note this is the application ID, not necessarily the same as the name value in the AppDef (required)
        :type name: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(AppDef, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method appdef_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "AppDef",
            '400': "str",
            '401': None,
        }

        return self.api_client.call_api(
            '/jarvice/appdef', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def apps_get(self, apikey : Annotated[Optional[StrictStr], Field(description="API key for user to authenticate ")] = None, username : Annotated[Optional[StrictStr], Field(description="Name of user to authenticate - if unspecified, public apps only")] = None, name : Annotated[Optional[StrictStr], Field(description="Name of application to return information for")] = None, version : Annotated[Optional[StrictInt], Field(description="Filter applications by appdef version")] = None, **kwargs) -> List[AppDef]:  # noqa: E501
        """Returns the Application Definition (AppDef) for a given application.  # noqa: E501

        On success, a JSON payload with application information for each available application, or for the specific application name if available. The application name is used as the dictionary key, and the data subkey contains the raw definition in JSON format. The price value is the application price itself, not including underlying machine price (which is available by querying the machine type using /jarvice/machines). Note that application name is the application ID, not necessarily the same as the human readable name in the AppDef for the given application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.apps_get(apikey, username, name, version, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate 
        :type apikey: str
        :param username: Name of user to authenticate - if unspecified, public apps only
        :type username: str
        :param name: Name of application to return information for
        :type name: str
        :param version: Filter applications by appdef version
        :type version: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[AppDef]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the apps_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.apps_get_with_http_info(apikey, username, name, version, **kwargs)  # noqa: E501

    @validate_arguments
    def apps_get_with_http_info(self, apikey : Annotated[Optional[StrictStr], Field(description="API key for user to authenticate ")] = None, username : Annotated[Optional[StrictStr], Field(description="Name of user to authenticate - if unspecified, public apps only")] = None, name : Annotated[Optional[StrictStr], Field(description="Name of application to return information for")] = None, version : Annotated[Optional[StrictInt], Field(description="Filter applications by appdef version")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Returns the Application Definition (AppDef) for a given application.  # noqa: E501

        On success, a JSON payload with application information for each available application, or for the specific application name if available. The application name is used as the dictionary key, and the data subkey contains the raw definition in JSON format. The price value is the application price itself, not including underlying machine price (which is available by querying the machine type using /jarvice/machines). Note that application name is the application ID, not necessarily the same as the human readable name in the AppDef for the given application.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.apps_get_with_http_info(apikey, username, name, version, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate 
        :type apikey: str
        :param username: Name of user to authenticate - if unspecified, public apps only
        :type username: str
        :param name: Name of application to return information for
        :type name: str
        :param version: Filter applications by appdef version
        :type version: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[AppDef], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'version'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method apps_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('version') is not None:  # noqa: E501
            _query_params.append(('version', _params['version']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[AppDef]",
            '400': "str",
            '401': None,
        }

        return self.api_client.call_api(
            '/jarvice/apps', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def billing_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], reportuser : Annotated[Optional[StrictStr], Field(description="Comma separated list of users to filter (if not specified: list all users)")] = None, zone : Annotated[Optional[StrictStr], Field(description="Zone for machines")] = None, billingcode : Annotated[Optional[StrictInt], Field(description="Billing code to filter by")] = None, statuses : Annotated[Optional[StrictStr], Field(description="Comma seperated string of statuses to filter by")] = None, machtypes : Annotated[Optional[StrictStr], Field(description="Comma seperated string of machine types to filter")] = None, jobapp : Annotated[Optional[StrictStr], Field(description="Application name to filter by (e.g. jarvice-ubuntu)")] = None, itemized : Annotated[Optional[StrictStr], Field(description="Set to true to generate itemized report")] = None, timeperiod : Annotated[Optional[StrictStr], Field(description="Includes jobs in the previous/current month or custom range (either last, current, or range)")] = None, startdate : Annotated[Optional[StrictStr], Field(description="Range start of time period to generate report (YYYY-MM-DD)")] = None, enddate : Annotated[Optional[StrictStr], Field(description="Range end of time period to generate report (YYYY-MM-DD)")] = None, **kwargs) -> bytearray:  # noqa: E501
        """(JXE/System Admins only) Returns billing report for JARVICE users  # noqa: E501

        On success, a CSV file containing generated billing report 1. Endpoint is for JARVICE XE System Administrators only 2. If reportuser is a payer of a team, all team members are included 3. Valid statuses fields are: COMPLETED, COMPLETED WITH ERROR, SUBMITTED, PROCESSING STARTING, CANCELED, EXEMPT, SEQUENTIALLY QUEUED, TERMINATED 4. Valid machtypes can be queried using /jarvice/machines API 5. startdate and enddate are required if timeperiod is set to range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.billing_get(apikey, username, reportuser, zone, billingcode, statuses, machtypes, jobapp, itemized, timeperiod, startdate, enddate, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param reportuser: Comma separated list of users to filter (if not specified: list all users)
        :type reportuser: str
        :param zone: Zone for machines
        :type zone: str
        :param billingcode: Billing code to filter by
        :type billingcode: int
        :param statuses: Comma seperated string of statuses to filter by
        :type statuses: str
        :param machtypes: Comma seperated string of machine types to filter
        :type machtypes: str
        :param jobapp: Application name to filter by (e.g. jarvice-ubuntu)
        :type jobapp: str
        :param itemized: Set to true to generate itemized report
        :type itemized: str
        :param timeperiod: Includes jobs in the previous/current month or custom range (either last, current, or range)
        :type timeperiod: str
        :param startdate: Range start of time period to generate report (YYYY-MM-DD)
        :type startdate: str
        :param enddate: Range end of time period to generate report (YYYY-MM-DD)
        :type enddate: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the billing_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.billing_get_with_http_info(apikey, username, reportuser, zone, billingcode, statuses, machtypes, jobapp, itemized, timeperiod, startdate, enddate, **kwargs)  # noqa: E501

    @validate_arguments
    def billing_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], reportuser : Annotated[Optional[StrictStr], Field(description="Comma separated list of users to filter (if not specified: list all users)")] = None, zone : Annotated[Optional[StrictStr], Field(description="Zone for machines")] = None, billingcode : Annotated[Optional[StrictInt], Field(description="Billing code to filter by")] = None, statuses : Annotated[Optional[StrictStr], Field(description="Comma seperated string of statuses to filter by")] = None, machtypes : Annotated[Optional[StrictStr], Field(description="Comma seperated string of machine types to filter")] = None, jobapp : Annotated[Optional[StrictStr], Field(description="Application name to filter by (e.g. jarvice-ubuntu)")] = None, itemized : Annotated[Optional[StrictStr], Field(description="Set to true to generate itemized report")] = None, timeperiod : Annotated[Optional[StrictStr], Field(description="Includes jobs in the previous/current month or custom range (either last, current, or range)")] = None, startdate : Annotated[Optional[StrictStr], Field(description="Range start of time period to generate report (YYYY-MM-DD)")] = None, enddate : Annotated[Optional[StrictStr], Field(description="Range end of time period to generate report (YYYY-MM-DD)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """(JXE/System Admins only) Returns billing report for JARVICE users  # noqa: E501

        On success, a CSV file containing generated billing report 1. Endpoint is for JARVICE XE System Administrators only 2. If reportuser is a payer of a team, all team members are included 3. Valid statuses fields are: COMPLETED, COMPLETED WITH ERROR, SUBMITTED, PROCESSING STARTING, CANCELED, EXEMPT, SEQUENTIALLY QUEUED, TERMINATED 4. Valid machtypes can be queried using /jarvice/machines API 5. startdate and enddate are required if timeperiod is set to range  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.billing_get_with_http_info(apikey, username, reportuser, zone, billingcode, statuses, machtypes, jobapp, itemized, timeperiod, startdate, enddate, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param reportuser: Comma separated list of users to filter (if not specified: list all users)
        :type reportuser: str
        :param zone: Zone for machines
        :type zone: str
        :param billingcode: Billing code to filter by
        :type billingcode: int
        :param statuses: Comma seperated string of statuses to filter by
        :type statuses: str
        :param machtypes: Comma seperated string of machine types to filter
        :type machtypes: str
        :param jobapp: Application name to filter by (e.g. jarvice-ubuntu)
        :type jobapp: str
        :param itemized: Set to true to generate itemized report
        :type itemized: str
        :param timeperiod: Includes jobs in the previous/current month or custom range (either last, current, or range)
        :type timeperiod: str
        :param startdate: Range start of time period to generate report (YYYY-MM-DD)
        :type startdate: str
        :param enddate: Range end of time period to generate report (YYYY-MM-DD)
        :type enddate: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'reportuser',
            'zone',
            'billingcode',
            'statuses',
            'machtypes',
            'jobapp',
            'itemized',
            'timeperiod',
            'startdate',
            'enddate'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method billing_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('reportuser') is not None:  # noqa: E501
            _query_params.append(('reportuser', _params['reportuser']))

        if _params.get('zone') is not None:  # noqa: E501
            _query_params.append(('zone', _params['zone']))

        if _params.get('billingcode') is not None:  # noqa: E501
            _query_params.append(('billingcode', _params['billingcode']))

        if _params.get('statuses') is not None:  # noqa: E501
            _query_params.append(('statuses', _params['statuses']))

        if _params.get('machtypes') is not None:  # noqa: E501
            _query_params.append(('machtypes', _params['machtypes']))

        if _params.get('jobapp') is not None:  # noqa: E501
            _query_params.append(('jobapp', _params['jobapp']))

        if _params.get('itemized') is not None:  # noqa: E501
            _query_params.append(('itemized', _params['itemized']))

        if _params.get('timeperiod') is not None:  # noqa: E501
            _query_params.append(('timeperiod', _params['timeperiod']))

        if _params.get('startdate') is not None:  # noqa: E501
            _query_params.append(('startdate', _params['startdate']))

        if _params.get('enddate') is not None:  # noqa: E501
            _query_params.append(('enddate', _params['enddate']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "bytearray",
            '400': "str",
            '401': None,
        }

        return self.api_client.call_api(
            '/jarvice/billing', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def connect_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> RuntimeConnect:  # noqa: E501
        """Requests the network address and user nimbix password (if set), for an interactive job.  # noqa: E501

        Requests the network address and user nimbix password (if set), for an interactive job. Additional Notes : 1. One of name or number must be specified 2. Job must be running an application endpoint that has interactive set to true in its AppDef in order for it to respond successfully 3. This method may take a few seconds to respond successfully after starting a job, as its connection parameters are not known until its application components start  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.connect_get(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RuntimeConnect
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the connect_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.connect_get_with_http_info(apikey, username, name, number, **kwargs)  # noqa: E501

    @validate_arguments
    def connect_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Requests the network address and user nimbix password (if set), for an interactive job.  # noqa: E501

        Requests the network address and user nimbix password (if set), for an interactive job. Additional Notes : 1. One of name or number must be specified 2. Job must be running an application endpoint that has interactive set to true in its AppDef in order for it to respond successfully 3. This method may take a few seconds to respond successfully after starting a job, as its connection parameters are not known until its application components start  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.connect_get_with_http_info(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RuntimeConnect, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'number'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method connect_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('number') is not None:  # noqa: E501
            _query_params.append(('number', _params['number']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "RuntimeConnect",
            '400': "str",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/jarvice/connect', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def events_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit)")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit)")] = None, **kwargs) -> str:  # noqa: E501
        """(JXE/System Admins only) Retrieves event logs for a running job that are related to the cluster infrastructure  # noqa: E501

        Retrieves event logs for a running job that are related to the cluster infrastructure  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.events_get(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit)
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit)
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the events_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.events_get_with_http_info(apikey, username, name, number, **kwargs)  # noqa: E501

    @validate_arguments
    def events_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit)")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit)")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """(JXE/System Admins only) Retrieves event logs for a running job that are related to the cluster infrastructure  # noqa: E501

        Retrieves event logs for a running job that are related to the cluster infrastructure  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.events_get_with_http_info(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit)
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit)
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'number'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method events_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('number') is not None:  # noqa: E501
            _query_params.append(('number', _params['number']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "str",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/jarvice/events', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def info_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> SchedJobStatusEntry:  # noqa: E501
        """Get info from job  # noqa: E501

        Get info from job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.info_get(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: SchedJobStatusEntry
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the info_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.info_get_with_http_info(apikey, username, name, number, **kwargs)  # noqa: E501

    @validate_arguments
    def info_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Get info from job  # noqa: E501

        Get info from job  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.info_get_with_http_info(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(SchedJobStatusEntry, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'number'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method info_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('number') is not None:  # noqa: E501
            _query_params.append(('number', _params['number']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "SchedJobStatusEntry",
            '400': "str",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/jarvice/info', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def jobs_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], completed : Annotated[Optional[StrictBool], Field(description="Set to true (case sensitive) to show only completed jobs")] = None, **kwargs) -> Dict[str, JobEntry]:  # noqa: E501
        """Returns job information and status for all queued and running jobs.  # noqa: E501

        On success, a JSON payload with job status for each queued or running job (keyed by job number), formatted like the response of /jarvice/status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.jobs_get(apikey, username, completed, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param completed: Set to true (case sensitive) to show only completed jobs
        :type completed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, JobEntry]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the jobs_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.jobs_get_with_http_info(apikey, username, completed, **kwargs)  # noqa: E501

    @validate_arguments
    def jobs_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], completed : Annotated[Optional[StrictBool], Field(description="Set to true (case sensitive) to show only completed jobs")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Returns job information and status for all queued and running jobs.  # noqa: E501

        On success, a JSON payload with job status for each queued or running job (keyed by job number), formatted like the response of /jarvice/status  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.jobs_get_with_http_info(apikey, username, completed, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param completed: Set to true (case sensitive) to show only completed jobs
        :type completed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, JobEntry], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'completed'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method jobs_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('completed') is not None:  # noqa: E501
            _query_params.append(('completed', _params['completed']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, JobEntry]",
            '400': "str",
            '401': None,
        }

        return self.api_client.call_api(
            '/jarvice/jobs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def license_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], **kwargs) -> str:  # noqa: E501
        """(JXE/System Admins only) Retrieves Jarvice license  # noqa: E501

        (JXE/System Admins only) Retrieves Jarvice license  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.license_get(apikey, username, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the license_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.license_get_with_http_info(apikey, username, **kwargs)  # noqa: E501

    @validate_arguments
    def license_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], **kwargs) -> ApiResponse:  # noqa: E501
        """(JXE/System Admins only) Retrieves Jarvice license  # noqa: E501

        (JXE/System Admins only) Retrieves Jarvice license  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.license_get_with_http_info(apikey, username, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method license_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "str",
            '401': None,
        }

        return self.api_client.call_api(
            '/jarvice/license', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def live_get(self, **kwargs) -> object:  # noqa: E501
        """Get info is API is alive  # noqa: E501

        Get info is API is alive  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.live_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the live_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.live_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def live_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """Get info is API is alive  # noqa: E501

        Get info is API is alive  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.live_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method live_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '404': None,
        }

        return self.api_client.call_api(
            '/jarvice/live', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def machines_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Name of machine type to return information for")] = None, vault : Annotated[Optional[StrictStr], Field(description="Vault name to use for machine compatibility; if specified, response will be a list of machines that can be used against that vault; if not specified, the user's default vault is used to determine machine compatibility")] = None, **kwargs) -> Dict[str, object]:  # noqa: E501
        """Returns information about available machine type(s).  # noqa: E501

        Returns information about available machine type(s). On success, a JSON payload with machine information for each available machine type, or for the specific machine name if available. The machine name is used as the dictionary key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.machines_get(apikey, username, name, vault, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Name of machine type to return information for
        :type name: str
        :param vault: Vault name to use for machine compatibility; if specified, response will be a list of machines that can be used against that vault; if not specified, the user's default vault is used to determine machine compatibility
        :type vault: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, object]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the machines_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.machines_get_with_http_info(apikey, username, name, vault, **kwargs)  # noqa: E501

    @validate_arguments
    def machines_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Name of machine type to return information for")] = None, vault : Annotated[Optional[StrictStr], Field(description="Vault name to use for machine compatibility; if specified, response will be a list of machines that can be used against that vault; if not specified, the user's default vault is used to determine machine compatibility")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Returns information about available machine type(s).  # noqa: E501

        Returns information about available machine type(s). On success, a JSON payload with machine information for each available machine type, or for the specific machine name if available. The machine name is used as the dictionary key.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.machines_get_with_http_info(apikey, username, name, vault, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Name of machine type to return information for
        :type name: str
        :param vault: Vault name to use for machine compatibility; if specified, response will be a list of machines that can be used against that vault; if not specified, the user's default vault is used to determine machine compatibility
        :type vault: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, object], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'vault'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method machines_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('vault') is not None:  # noqa: E501
            _query_params.append(('vault', _params['vault']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, object]",
            '400': "str",
            '401': None,
        }

        return self.api_client.call_api(
            '/jarvice/machines', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def metrics_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit) *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> RuntimeMetrics:  # noqa: E501
        """Returns the last known CPU and memory utilization metrics for a given job.  # noqa: E501

        Returns the last known CPU and memory utilization metrics for a given job. On success, a JSON payload indicating summary values in the summary key, and itemized values (one for each parallel node in the job) in the itemized key. Additional Notes : 1. One of name or number must be specified 2. cpu_used is always a percentage value (percentage of total CPU resource allocated), while memory_used and memory_total are always in kilobytes. 3. In the summary section, cpu_used is the average of all CPU utilization across all nodes in the job, while the memory values are the sum total, in kilobytes. 4. The percentage of memory utilized from the summary can be calculated by dividing memory_used by memory_total and multiplying by 100. 5. All values are \"point in time\" rather than rolling average or any type of cumulative calculation, and are collected periodically (typically every 30 seconds) 6. This endpoint may return a 404 for approximately the first minute that a job is running, until metrics become available  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.metrics_get(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit) *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: RuntimeMetrics
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the metrics_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.metrics_get_with_http_info(apikey, username, name, number, **kwargs)  # noqa: E501

    @validate_arguments
    def metrics_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit) *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Returns the last known CPU and memory utilization metrics for a given job.  # noqa: E501

        Returns the last known CPU and memory utilization metrics for a given job. On success, a JSON payload indicating summary values in the summary key, and itemized values (one for each parallel node in the job) in the itemized key. Additional Notes : 1. One of name or number must be specified 2. cpu_used is always a percentage value (percentage of total CPU resource allocated), while memory_used and memory_total are always in kilobytes. 3. In the summary section, cpu_used is the average of all CPU utilization across all nodes in the job, while the memory values are the sum total, in kilobytes. 4. The percentage of memory utilized from the summary can be calculated by dividing memory_used by memory_total and multiplying by 100. 5. All values are \"point in time\" rather than rolling average or any type of cumulative calculation, and are collected periodically (typically every 30 seconds) 6. This endpoint may return a 404 for approximately the first minute that a job is running, until metrics become available  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.metrics_get_with_http_info(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit) *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(RuntimeMetrics, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'number'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method metrics_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('number') is not None:  # noqa: E501
            _query_params.append(('number', _params['number']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "RuntimeMetrics",
            '400': "str",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/jarvice/metrics', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def output_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit) *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, lines : Annotated[Optional[StrictInt], Field(description="Number of lines to tail from the end - use 0 to return all lines rather than just a tail")] = None, **kwargs) -> str:  # noqa: E501
        """Returns a tail (or optionally all) of the output of a completed job.  # noqa: E501

        Returns a tail (or optionally all) of the output of a completed job. On success, the requested output tail in text/plain format (with single \\n for line breaks), up to and including the number of lines requested; if the total length of the output is less than lines requested, the entire output is returned. If lines requested is 0, all lines in the output are returned rather than just a tail of it. Additional Notes : 1. One of name or number must be specified 2. Job must have completed; to get the output of a running job instead, use /jarvice/tail  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.output_get(apikey, username, name, number, lines, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit) *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param lines: Number of lines to tail from the end - use 0 to return all lines rather than just a tail
        :type lines: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the output_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.output_get_with_http_info(apikey, username, name, number, lines, **kwargs)  # noqa: E501

    @validate_arguments
    def output_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit) *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, lines : Annotated[Optional[StrictInt], Field(description="Number of lines to tail from the end - use 0 to return all lines rather than just a tail")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Returns a tail (or optionally all) of the output of a completed job.  # noqa: E501

        Returns a tail (or optionally all) of the output of a completed job. On success, the requested output tail in text/plain format (with single \\n for line breaks), up to and including the number of lines requested; if the total length of the output is less than lines requested, the entire output is returned. If lines requested is 0, all lines in the output are returned rather than just a tail of it. Additional Notes : 1. One of name or number must be specified 2. Job must have completed; to get the output of a running job instead, use /jarvice/tail  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.output_get_with_http_info(apikey, username, name, number, lines, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit) *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param lines: Number of lines to tail from the end - use 0 to return all lines rather than just a tail
        :type lines: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'number',
            'lines'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method output_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('number') is not None:  # noqa: E501
            _query_params.append(('number', _params['number']))

        if _params.get('lines') is not None:  # noqa: E501
            _query_params.append(('lines', _params['lines']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "str",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/jarvice/output', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def projects_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], **kwargs) -> Dict[str, List[str]]:  # noqa: E501
        """(JXE/System Admins only) Returns all JARVICE projects and members  # noqa: E501

        (JXE/System Admins only) Returns all JARVICE projects and members Additional Notes: 1. Endpoint is for JARVICE XE System Administrators only 2. Project name contains the project owner, <owner>-<project-name>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.projects_get(apikey, username, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, List[str]]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the projects_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.projects_get_with_http_info(apikey, username, **kwargs)  # noqa: E501

    @validate_arguments
    def projects_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], **kwargs) -> ApiResponse:  # noqa: E501
        """(JXE/System Admins only) Returns all JARVICE projects and members  # noqa: E501

        (JXE/System Admins only) Returns all JARVICE projects and members Additional Notes: 1. Endpoint is for JARVICE XE System Administrators only 2. Project name contains the project owner, <owner>-<project-name>  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.projects_get_with_http_info(apikey, username, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, List[str]], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method projects_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, List[str]]",
            '400': "str",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/jarvice/projects', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def queues_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Name of queue to return information for")] = None, info : Annotated[Optional[StrictInt], Field(description="Display additional info for each queue")] = None, **kwargs) -> List[Queue]:  # noqa: E501
        """(JXE only) Returns information about available queue(s).  # noqa: E501

        Retrieves event logs for a running job that are related to the cluster infrastructure  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.queues_get(apikey, username, name, info, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Name of queue to return information for
        :type name: str
        :param info: Display additional info for each queue
        :type info: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[Queue]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the queues_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.queues_get_with_http_info(apikey, username, name, info, **kwargs)  # noqa: E501

    @validate_arguments
    def queues_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Name of queue to return information for")] = None, info : Annotated[Optional[StrictInt], Field(description="Display additional info for each queue")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """(JXE only) Returns information about available queue(s).  # noqa: E501

        Retrieves event logs for a running job that are related to the cluster infrastructure  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.queues_get_with_http_info(apikey, username, name, info, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Name of queue to return information for
        :type name: str
        :param info: Display additional info for each queue
        :type info: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[Queue], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'info'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method queues_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('info') is not None:  # noqa: E501
            _query_params.append(('info', _params['info']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[Queue]",
            '400': "str",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/jarvice/queues', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def ready_get(self, **kwargs) -> Dict[str, object]:  # noqa: E501
        """Get info if DAL is ready  # noqa: E501

        Get info if DAL is ready  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.ready_get(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, object]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the ready_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.ready_get_with_http_info(**kwargs)  # noqa: E501

    @validate_arguments
    def ready_get_with_http_info(self, **kwargs) -> ApiResponse:  # noqa: E501
        """Get info if DAL is ready  # noqa: E501

        Get info if DAL is ready  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.ready_get_with_http_info(async_req=True)
        >>> result = thread.get()

        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, object], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method ready_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, object]",
            '400': "str",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/jarvice/ready', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def screenshot_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, width : Annotated[Optional[StrictInt], Field(description="Pixel width to restrict screenshot to")] = None, height : Annotated[Optional[StrictInt], Field(description="Pixel height to restrict screenshot to")] = None, emphatic : Annotated[Optional[StrictBool], Field(description="If specified, emphatically resize (disregarding aspect ratio) to specified width and/or height")] = None, **kwargs) -> bytearray:  # noqa: E501
        """Returns a screenshot for a running job (if it is graphical).  # noqa: E501

        Returns a screenshot for a running job (if it is graphical). On success, an image/png payload with the requested screenshot if available Additional Notes: 1. One of name or number must be specified 2. If emphatic is not specified, but width and/or height is, the aspect ratio of the screenshot image is preserved when resizing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.screenshot_get(apikey, username, name, number, width, height, emphatic, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param width: Pixel width to restrict screenshot to
        :type width: int
        :param height: Pixel height to restrict screenshot to
        :type height: int
        :param emphatic: If specified, emphatically resize (disregarding aspect ratio) to specified width and/or height
        :type emphatic: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: bytearray
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the screenshot_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.screenshot_get_with_http_info(apikey, username, name, number, width, height, emphatic, **kwargs)  # noqa: E501

    @validate_arguments
    def screenshot_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, width : Annotated[Optional[StrictInt], Field(description="Pixel width to restrict screenshot to")] = None, height : Annotated[Optional[StrictInt], Field(description="Pixel height to restrict screenshot to")] = None, emphatic : Annotated[Optional[StrictBool], Field(description="If specified, emphatically resize (disregarding aspect ratio) to specified width and/or height")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Returns a screenshot for a running job (if it is graphical).  # noqa: E501

        Returns a screenshot for a running job (if it is graphical). On success, an image/png payload with the requested screenshot if available Additional Notes: 1. One of name or number must be specified 2. If emphatic is not specified, but width and/or height is, the aspect ratio of the screenshot image is preserved when resizing.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.screenshot_get_with_http_info(apikey, username, name, number, width, height, emphatic, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param width: Pixel width to restrict screenshot to
        :type width: int
        :param height: Pixel height to restrict screenshot to
        :type height: int
        :param emphatic: If specified, emphatically resize (disregarding aspect ratio) to specified width and/or height
        :type emphatic: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(bytearray, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'number',
            'width',
            'height',
            'emphatic'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method screenshot_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('number') is not None:  # noqa: E501
            _query_params.append(('number', _params['number']))

        if _params.get('width') is not None:  # noqa: E501
            _query_params.append(('width', _params['width']))

        if _params.get('height') is not None:  # noqa: E501
            _query_params.append(('height', _params['height']))

        if _params.get('emphatic') is not None:  # noqa: E501
            _query_params.append(('emphatic', _params['emphatic']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "bytearray",
            '400': "str",
            '401': None,
            '404': None,
            '501': None,
        }

        return self.api_client.call_api(
            '/jarvice/screenshot', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def status_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> Dict[str, SchedJobStatusEntry]:  # noqa: E501
        """Queries status for a previously submitted job.  # noqa: E501

        Queries status for a previously submitted job. Additional Notes: 1. One of name or number must be specified 2. All \"time\" values are represented in UNIX time (seconds since the Epoch); values may be 0 if the data is not yet available (e.g. a job that hasn't completed yet will have a 0 for job_end_time); additional values may be returned in the future.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.status_get(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, SchedJobStatusEntry]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the status_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.status_get_with_http_info(apikey, username, name, number, **kwargs)  # noqa: E501

    @validate_arguments
    def status_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Queries status for a previously submitted job.  # noqa: E501

        Queries status for a previously submitted job. Additional Notes: 1. One of name or number must be specified 2. All \"time\" values are represented in UNIX time (seconds since the Epoch); values may be 0 if the data is not yet available (e.g. a job that hasn't completed yet will have a 0 for job_end_time); additional values may be returned in the future.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.status_get_with_http_info(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, SchedJobStatusEntry], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'number'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method status_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('number') is not None:  # noqa: E501
            _query_params.append(('number', _params['number']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, SchedJobStatusEntry]",
            '400': "str",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/jarvice/status', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def tail_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit) *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, lines : Annotated[Optional[StrictInt], Field(description="Number of lines to tail from the end - use 0 to return all lines rather than just a tail")] = None, **kwargs) -> str:  # noqa: E501
        """Returns a tail (or optionally all) of the output of a completed job.  # noqa: E501

        Returns a tail (or optionally all) of the output of a completed job. On success, the requested output tail in text/plain format (with single \\n for line breaks), up to and including the number of lines requested; if the total length of the output is less than lines requested, the entire output is returned. If lines requested is 0, all lines in the output are returned rather than just a tail of it. Additional Notes : 1. One of name or number must be specified 2. Job must still be running; to get the output of a completed job instead, use /jarvice/output  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tail_get(apikey, username, name, number, lines, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit) *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param lines: Number of lines to tail from the end - use 0 to return all lines rather than just a tail
        :type lines: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: str
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the tail_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.tail_get_with_http_info(apikey, username, name, number, lines, **kwargs)  # noqa: E501

    @validate_arguments
    def tail_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit) *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, lines : Annotated[Optional[StrictInt], Field(description="Number of lines to tail from the end - use 0 to return all lines rather than just a tail")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Returns a tail (or optionally all) of the output of a completed job.  # noqa: E501

        Returns a tail (or optionally all) of the output of a completed job. On success, the requested output tail in text/plain format (with single \\n for line breaks), up to and including the number of lines requested; if the total length of the output is less than lines requested, the entire output is returned. If lines requested is 0, all lines in the output are returned rather than just a tail of it. Additional Notes : 1. One of name or number must be specified 2. Job must still be running; to get the output of a completed job instead, use /jarvice/output  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.tail_get_with_http_info(apikey, username, name, number, lines, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit) *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param lines: Number of lines to tail from the end - use 0 to return all lines rather than just a tail
        :type lines: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(str, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'number',
            'lines'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method tail_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('number') is not None:  # noqa: E501
            _query_params.append(('number', _params['number']))

        if _params.get('lines') is not None:  # noqa: E501
            _query_params.append(('lines', _params['lines']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "str",
            '400': "str",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/jarvice/tail', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def teamjobs_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], completed : Annotated[Optional[StrictBool], Field(description="Set to true (case sensitive) to show only completed jobs")] = None, **kwargs) -> Dict[str, JobEntry]:  # noqa: E501
        """Returns job information and status for all queued and running jobs for an entire team.  # noqa: E501

        Returns job information and status for all queued and running jobs for an entire team. On success, a JSON payload with job status for each queued or running job (keyed by job number), formatted like the response of /jarvice/status Note: If username does not refer to a team payer, only jobs for that user will be listed  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.teamjobs_get(apikey, username, completed, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param completed: Set to true (case sensitive) to show only completed jobs
        :type completed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, JobEntry]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the teamjobs_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.teamjobs_get_with_http_info(apikey, username, completed, **kwargs)  # noqa: E501

    @validate_arguments
    def teamjobs_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], completed : Annotated[Optional[StrictBool], Field(description="Set to true (case sensitive) to show only completed jobs")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Returns job information and status for all queued and running jobs for an entire team.  # noqa: E501

        Returns job information and status for all queued and running jobs for an entire team. On success, a JSON payload with job status for each queued or running job (keyed by job number), formatted like the response of /jarvice/status Note: If username does not refer to a team payer, only jobs for that user will be listed  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.teamjobs_get_with_http_info(apikey, username, completed, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param completed: Set to true (case sensitive) to show only completed jobs
        :type completed: bool
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, JobEntry], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'completed'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method teamjobs_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('completed') is not None:  # noqa: E501
            _query_params.append(('completed', _params['completed']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, JobEntry]",
            '400': "str",
            '401': None,
        }

        return self.api_client.call_api(
            '/jarvice/teamjobs', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def teamusers_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], **kwargs) -> Dict[str, TeamUser]:  # noqa: E501
        """(Team Admins only) Returns a list of JARVICE users who are members of the callers team  # noqa: E501

        (Team Admins only) Returns a list of JARVICE users who are members of the callers team On success, a JSON payload with a list of team members  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.teamusers_get(apikey, username, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, TeamUser]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the teamusers_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.teamusers_get_with_http_info(apikey, username, **kwargs)  # noqa: E501

    @validate_arguments
    def teamusers_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], **kwargs) -> ApiResponse:  # noqa: E501
        """(Team Admins only) Returns a list of JARVICE users who are members of the callers team  # noqa: E501

        (Team Admins only) Returns a list of JARVICE users who are members of the callers team On success, a JSON payload with a list of team members  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.teamusers_get_with_http_info(apikey, username, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, TeamUser], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method teamusers_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, TeamUser]",
            '400': "str",
            '401': None,
        }

        return self.api_client.call_api(
            '/jarvice/teamusers', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def vault_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], vault : Annotated[StrictStr, Field(..., description="Name of vault to list files in")], path : Annotated[StrictStr, Field(..., description="Directory in vault to list files in")], details : Annotated[Optional[StrictBool], Field(description="Include file details such as size and modification time if set to true")] = None, sort : Annotated[Optional[StrictStr], Field(description="either n, s, or m to sort by name, size, or modification time (respectively) in ascending order; use uppercase for reverse sort")] = None, **kwargs) -> List[List[str]]:  # noqa: E501
        """List files in a vault.  # noqa: E501

        List files in a vault. On success, a list of lists in application/json format; each element pertains to a file or directory, and includes its name, size, and modification time \"modification time\" (3rd value in each element) is represented in UNIX time (seconds since the Epoch) Additional Notes: 1. Listing is not recursive - only the files in the directory specified by the path parameter are listed 2. Directories are marked with a trailing / character 3. Both size and modification time may be 0 if details is not true 4. Sorting by anything other than name requires details to be set to true 5. Requesting a detailed listing may be significantly slower for certain storage topologies or if listing very large numbers of files; use only if necessary  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vault_get(apikey, username, vault, path, details, sort, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param vault: Name of vault to list files in (required)
        :type vault: str
        :param path: Directory in vault to list files in (required)
        :type path: str
        :param details: Include file details such as size and modification time if set to true
        :type details: bool
        :param sort: either n, s, or m to sort by name, size, or modification time (respectively) in ascending order; use uppercase for reverse sort
        :type sort: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: List[List[str]]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the vault_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.vault_get_with_http_info(apikey, username, vault, path, details, sort, **kwargs)  # noqa: E501

    @validate_arguments
    def vault_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate ")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], vault : Annotated[StrictStr, Field(..., description="Name of vault to list files in")], path : Annotated[StrictStr, Field(..., description="Directory in vault to list files in")], details : Annotated[Optional[StrictBool], Field(description="Include file details such as size and modification time if set to true")] = None, sort : Annotated[Optional[StrictStr], Field(description="either n, s, or m to sort by name, size, or modification time (respectively) in ascending order; use uppercase for reverse sort")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """List files in a vault.  # noqa: E501

        List files in a vault. On success, a list of lists in application/json format; each element pertains to a file or directory, and includes its name, size, and modification time \"modification time\" (3rd value in each element) is represented in UNIX time (seconds since the Epoch) Additional Notes: 1. Listing is not recursive - only the files in the directory specified by the path parameter are listed 2. Directories are marked with a trailing / character 3. Both size and modification time may be 0 if details is not true 4. Sorting by anything other than name requires details to be set to true 5. Requesting a detailed listing may be significantly slower for certain storage topologies or if listing very large numbers of files; use only if necessary  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.vault_get_with_http_info(apikey, username, vault, path, details, sort, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate  (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param vault: Name of vault to list files in (required)
        :type vault: str
        :param path: Directory in vault to list files in (required)
        :type path: str
        :param details: Include file details such as size and modification time if set to true
        :type details: bool
        :param sort: either n, s, or m to sort by name, size, or modification time (respectively) in ascending order; use uppercase for reverse sort
        :type sort: str
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(List[List[str]], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'vault',
            'path',
            'details',
            'sort'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method vault_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('vault') is not None:  # noqa: E501
            _query_params.append(('vault', _params['vault']))

        if _params.get('path') is not None:  # noqa: E501
            _query_params.append(('path', _params['path']))

        if _params.get('details') is not None:  # noqa: E501
            _query_params.append(('details', _params['details']))

        if _params.get('sort') is not None:  # noqa: E501
            _query_params.append(('sort', _params['sort']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "List[List[str]]",
            '400': "str",
            '401': None,
        }

        return self.api_client.call_api(
            '/jarvice/vault', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
