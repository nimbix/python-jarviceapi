# coding: utf-8

"""
    Jarvice API

    The JARVICE API allows full control on running jobs as well as managing applications via PushToComputeâ„¢.  # noqa: E501

    The version of the OpenAPI document: 1.0
    Contact: support@nimbix.net
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


from __future__ import annotations
import pprint
import re  # noqa: F401
import json


from typing import Optional
from pydantic import BaseModel, Field, StrictBool, StrictStr
from jarviceapi_client.models.app_def_ident import AppDefIdent
from jarviceapi_client.models.application import Application
from jarviceapi_client.models.container import Container
from jarviceapi_client.models.hpc_req import HpcReq
from jarviceapi_client.models.machine import Machine
from jarviceapi_client.models.submit_user import SubmitUser
from jarviceapi_client.models.vault import Vault

class Submission(BaseModel):
    """
    Submission
    """
    app: Optional[StrictStr] = None
    application: Optional[Application] = None
    container: Optional[Container] = None
    gen_sshkey: Optional[StrictBool] = None
    hpc: Optional[HpcReq] = None
    identity: Optional[AppDefIdent] = None
    job_label: Optional[StrictStr] = None
    job_project: Optional[StrictStr] = None
    jobsub: Optional[StrictStr] = None
    licenses: Optional[StrictStr] = None
    machine: Optional[Machine] = None
    nopasssubt: Optional[StrictBool] = Field(None, description="subt is not a typo")
    public_ip: Optional[StrictBool] = Field(None, alias="publicIP")
    queue: Optional[StrictStr] = None
    test_comment: Optional[StrictStr] = Field(None, description="Remove later")
    user: Optional[SubmitUser] = None
    vault: Optional[Vault] = None
    __properties = ["app", "application", "container", "gen_sshkey", "hpc", "identity", "job_label", "job_project", "jobsub", "licenses", "machine", "nopasssubt", "publicIP", "queue", "test_comment", "user", "vault"]

    class Config:
        """Pydantic configuration"""
        allow_population_by_field_name = True
        validate_assignment = True

    def to_str(self) -> str:
        """Returns the string representation of the model using alias"""
        return pprint.pformat(self.dict(by_alias=True))

    def to_json(self) -> str:
        """Returns the JSON representation of the model using alias"""
        return json.dumps(self.to_dict())

    @classmethod
    def from_json(cls, json_str: str) -> Submission:
        """Create an instance of Submission from a JSON string"""
        return cls.from_dict(json.loads(json_str))

    def to_dict(self):
        """Returns the dictionary representation of the model using alias"""
        _dict = self.dict(by_alias=True,
                          exclude={
                          },
                          exclude_none=True)
        # override the default output from pydantic by calling `to_dict()` of application
        if self.application:
            _dict['application'] = self.application.to_dict()
        # override the default output from pydantic by calling `to_dict()` of container
        if self.container:
            _dict['container'] = self.container.to_dict()
        # override the default output from pydantic by calling `to_dict()` of hpc
        if self.hpc:
            _dict['hpc'] = self.hpc.to_dict()
        # override the default output from pydantic by calling `to_dict()` of identity
        if self.identity:
            _dict['identity'] = self.identity.to_dict()
        # override the default output from pydantic by calling `to_dict()` of machine
        if self.machine:
            _dict['machine'] = self.machine.to_dict()
        # override the default output from pydantic by calling `to_dict()` of user
        if self.user:
            _dict['user'] = self.user.to_dict()
        # override the default output from pydantic by calling `to_dict()` of vault
        if self.vault:
            _dict['vault'] = self.vault.to_dict()
        return _dict

    @classmethod
    def from_dict(cls, obj: dict) -> Submission:
        """Create an instance of Submission from a dict"""
        if obj is None:
            return None

        if not isinstance(obj, dict):
            return Submission.parse_obj(obj)

        _obj = Submission.parse_obj({
            "app": obj.get("app"),
            "application": Application.from_dict(obj.get("application")) if obj.get("application") is not None else None,
            "container": Container.from_dict(obj.get("container")) if obj.get("container") is not None else None,
            "gen_sshkey": obj.get("gen_sshkey"),
            "hpc": HpcReq.from_dict(obj.get("hpc")) if obj.get("hpc") is not None else None,
            "identity": AppDefIdent.from_dict(obj.get("identity")) if obj.get("identity") is not None else None,
            "job_label": obj.get("job_label"),
            "job_project": obj.get("job_project"),
            "jobsub": obj.get("jobsub"),
            "licenses": obj.get("licenses"),
            "machine": Machine.from_dict(obj.get("machine")) if obj.get("machine") is not None else None,
            "nopasssubt": obj.get("nopasssubt"),
            "public_ip": obj.get("publicIP"),
            "queue": obj.get("queue"),
            "test_comment": obj.get("test_comment"),
            "user": SubmitUser.from_dict(obj.get("user")) if obj.get("user") is not None else None,
            "vault": Vault.from_dict(obj.get("vault")) if obj.get("vault") is not None else None
        })
        return _obj

