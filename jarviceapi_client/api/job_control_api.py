# coding: utf-8

"""
    Jarvice API

    The JARVICE API allows full control on running jobs as well as managing applications via PushToComputeâ„¢.  # noqa: E501

    The version of the OpenAPI document: 1.0
    Contact: support@nimbix.net
    Generated by OpenAPI Generator (https://openapi-generator.tech)

    Do not edit the class manually.
"""


import re  # noqa: F401
import io
import warnings

from pydantic import validate_arguments, ValidationError
from typing_extensions import Annotated

from pydantic import Field, StrictInt, StrictStr

from typing import Any, Dict, Optional

from jarviceapi_client.models.submission import Submission

from jarviceapi_client.api_client import ApiClient
from jarviceapi_client.api_response import ApiResponse
from jarviceapi_client.exceptions import (  # noqa: F401
    ApiTypeError,
    ApiValueError
)


class JobControlApi(object):
    """NOTE: This class is auto generated by OpenAPI Generator
    Ref: https://openapi-generator.tech

    Do not edit the class manually.
    """

    def __init__(self, api_client=None):
        if api_client is None:
            api_client = ApiClient.get_default()
        self.api_client = api_client

    @validate_arguments
    def action_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], action : Annotated[StrictStr, Field(..., description="The name of the action to run (must be a valid action from /jarvice/info)")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> object:  # noqa: E501
        """(Deprecated) Perform a configured action on your job  # noqa: E501

        Executes an application-defined command inside a running job. The command runs asynchronously and its standard output/standard error is accessible with /jarvice/tail while the job is running.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.action_get(apikey, username, action, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param action: The name of the action to run (must be a valid action from /jarvice/info) (required)
        :type action: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the action_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.action_get_with_http_info(apikey, username, action, name, number, **kwargs)  # noqa: E501

    @validate_arguments
    def action_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], action : Annotated[StrictStr, Field(..., description="The name of the action to run (must be a valid action from /jarvice/info)")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """(Deprecated) Perform a configured action on your job  # noqa: E501

        Executes an application-defined command inside a running job. The command runs asynchronously and its standard output/standard error is accessible with /jarvice/tail while the job is running.  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.action_get_with_http_info(apikey, username, action, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param action: The name of the action to run (must be a valid action from /jarvice/info) (required)
        :type action: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        warnings.warn("GET /jarvice/action is deprecated.", DeprecationWarning)

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'action',
            'name',
            'number'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method action_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('number') is not None:  # noqa: E501
            _query_params.append(('number', _params['number']))

        if _params.get('action') is not None:  # noqa: E501
            _query_params.append(('action', _params['action']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "str",
            '401': None,
            '404': None,
        }

        return self.api_client.call_api(
            '/jarvice/action', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def batch_post(self, var_json : Annotated[Submission, Field(..., description="JSON payload to run the compute job, generated as specified above. If copying from the web portal, paste the text into a file or script to use as the JSON payload to submit. Please note that authentication is performed from the username and apikey values in the JSON itself.")], **kwargs) -> Dict[str, object]:  # noqa: E501
        """Submits a job for processing.  # noqa: E501

        Submits a job for processing. The body is in JSON format similar to /jarvice/submit with the addition of the container blob. NOTE: Public containers from DockerHub must include the library/ prefix. e.g. library/ubuntu:latest On success, a JSON payload indicating the job name and job number (with name and number keys). Additional Notes: 1. All boolean values default to false if not specified 2. The nodes parameter in the machine section defaults to 1 if not specified 3. Even if a vault section is specified, password is optional and should only be supplied for encrypted block vaults 4. Even if vault section is specified, vault objects is optional and applies only to object storage vaults; it indicates which objects should be moved into the environments's backing store for processing. If readonly is set to false, JARVICE automatically copies any new or changed objects from the backing store back to the object storage on normal job completion (but not immediate termination with /jarvice/terminate).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.batch_post(var_json, async_req=True)
        >>> result = thread.get()

        :param var_json: JSON payload to run the compute job, generated as specified above. If copying from the web portal, paste the text into a file or script to use as the JSON payload to submit. Please note that authentication is performed from the username and apikey values in the JSON itself. (required)
        :type var_json: Submission
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, object]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the batch_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.batch_post_with_http_info(var_json, **kwargs)  # noqa: E501

    @validate_arguments
    def batch_post_with_http_info(self, var_json : Annotated[Submission, Field(..., description="JSON payload to run the compute job, generated as specified above. If copying from the web portal, paste the text into a file or script to use as the JSON payload to submit. Please note that authentication is performed from the username and apikey values in the JSON itself.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Submits a job for processing.  # noqa: E501

        Submits a job for processing. The body is in JSON format similar to /jarvice/submit with the addition of the container blob. NOTE: Public containers from DockerHub must include the library/ prefix. e.g. library/ubuntu:latest On success, a JSON payload indicating the job name and job number (with name and number keys). Additional Notes: 1. All boolean values default to false if not specified 2. The nodes parameter in the machine section defaults to 1 if not specified 3. Even if a vault section is specified, password is optional and should only be supplied for encrypted block vaults 4. Even if vault section is specified, vault objects is optional and applies only to object storage vaults; it indicates which objects should be moved into the environments's backing store for processing. If readonly is set to false, JARVICE automatically copies any new or changed objects from the backing store back to the object storage on normal job completion (but not immediate termination with /jarvice/terminate).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.batch_post_with_http_info(var_json, async_req=True)
        >>> result = thread.get()

        :param var_json: JSON payload to run the compute job, generated as specified above. If copying from the web portal, paste the text into a file or script to use as the JSON payload to submit. Please note that authentication is performed from the username and apikey values in the JSON itself. (required)
        :type var_json: Submission
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, object], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_json'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method batch_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['var_json'] is not None:
            _body_params = _params['var_json']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, object]",
            '400': None,
            '401': None,
            '404': None,
            '429': None,
            '500': None,
            '501': None,
        }

        return self.api_client.call_api(
            '/jarvice/batch', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def shutdown_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> object:  # noqa: E501
        """Requests a graceful termination of a job, executing the operating system poweroff mechanism if applicable.  # noqa: E501

        Requests a graceful termination of a job, executing the operating system poweroff mechanism if applicable. On success: {\"status\": \"shutdown requested\"} A job not in PROCESSING STARTING status will return an error, e.g. {\"error\": \"Running job is not found\"} Additional Notes: 1. One of name or number must be specified 2. Shutdown is requested asynchronously - job status can be monitored with /jarvice/status 3. Current job status must be PROCESSING STARTING as indicated by output of /jarvice/status, e.g. {\"job_status\": \"PROCESSING STARTING\"}. For other states, see /jarvice/terminate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.shutdown_get(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the shutdown_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.shutdown_get_with_http_info(apikey, username, name, number, **kwargs)  # noqa: E501

    @validate_arguments
    def shutdown_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Requests a graceful termination of a job, executing the operating system poweroff mechanism if applicable.  # noqa: E501

        Requests a graceful termination of a job, executing the operating system poweroff mechanism if applicable. On success: {\"status\": \"shutdown requested\"} A job not in PROCESSING STARTING status will return an error, e.g. {\"error\": \"Running job is not found\"} Additional Notes: 1. One of name or number must be specified 2. Shutdown is requested asynchronously - job status can be monitored with /jarvice/status 3. Current job status must be PROCESSING STARTING as indicated by output of /jarvice/status, e.g. {\"job_status\": \"PROCESSING STARTING\"}. For other states, see /jarvice/terminate  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.shutdown_get_with_http_info(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'number'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method shutdown_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('number') is not None:  # noqa: E501
            _query_params.append(('number', _params['number']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "str",
            '401': None,
            '404': "object",
        }

        return self.api_client.call_api(
            '/jarvice/shutdown', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def signal_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, signal : Annotated[Optional[StrictInt], Field(description="Signal to send to job")] = None, **kwargs) -> object:  # noqa: E501
        """Send a signal to a running job (e.g. SIGTSTP/20).  # noqa: E501

        Send a signal to a running job (e.g. SIGTSTP/20). On success: {\"signal\": <signal>, \"pid\": <pid>} Where pid is the process that receives the signal. Additional Notes: 1. One of name or number must be specified 2. signal must use the integer representation for the signal 3. /jarvice/signal will set the substatus 'Suspended by user' which is updated on the JARVICE Dashboard. This substatus is cleared by signaling SIGCONT/18. Processes that ignore SIGTSTP are not suspended even if the job substatus is set to 'Suspended by user' 4. JarviceXE applications can override signal behavior by setting JARVICE_SIGNAL_OVERRIDE environment variable to a custom script to handle signals sent to the application from the JARVICE API. (see example Dockerfile using ENV to set JARVICE_SIGNAL_OVERRIDE and override script)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.signal_get(apikey, username, name, number, signal, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param signal: Signal to send to job
        :type signal: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: object
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the signal_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.signal_get_with_http_info(apikey, username, name, number, signal, **kwargs)  # noqa: E501

    @validate_arguments
    def signal_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, signal : Annotated[Optional[StrictInt], Field(description="Signal to send to job")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Send a signal to a running job (e.g. SIGTSTP/20).  # noqa: E501

        Send a signal to a running job (e.g. SIGTSTP/20). On success: {\"signal\": <signal>, \"pid\": <pid>} Where pid is the process that receives the signal. Additional Notes: 1. One of name or number must be specified 2. signal must use the integer representation for the signal 3. /jarvice/signal will set the substatus 'Suspended by user' which is updated on the JARVICE Dashboard. This substatus is cleared by signaling SIGCONT/18. Processes that ignore SIGTSTP are not suspended even if the job substatus is set to 'Suspended by user' 4. JarviceXE applications can override signal behavior by setting JARVICE_SIGNAL_OVERRIDE environment variable to a custom script to handle signals sent to the application from the JARVICE API. (see example Dockerfile using ENV to set JARVICE_SIGNAL_OVERRIDE and override script)  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.signal_get_with_http_info(apikey, username, name, number, signal, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param signal: Signal to send to job
        :type signal: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(object, status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'number',
            'signal'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method signal_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('number') is not None:  # noqa: E501
            _query_params.append(('number', _params['number']))

        if _params.get('signal') is not None:  # noqa: E501
            _query_params.append(('signal', _params['signal']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "object",
            '400': "str",
            '401': None,
            '404': "object",
        }

        return self.api_client.call_api(
            '/jarvice/signal', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def submit_post(self, var_json : Annotated[Submission, Field(..., description="JSON payload to run the compute job, generated as specified above. If copying from the web portal, paste the text into a file or script to use as the JSON payload to submit. Please note that authentication is performed from the username and apikey values in the JSON itself.")], **kwargs) -> Dict[str, object]:  # noqa: E501
        """Submits a job for processing.  # noqa: E501

        Submits a job for processing. The body is in JSON format and can be generated from the JARVICE web portal by clicking the PREVIEW SUBMISSION tab in the task builder and copying its contents to the clipboard. Click the copy icon above the SUBMIT button to copy the contents of the API call to the clipboard. NOTE: Adding the identity object in the submission json will replace the NIMBIX Application Environment nimbix user. The JARVICE API cannot override an identity set by an AppDef file. On success, a JSON payload indicating the job name and job number (with name and number keys). Additional Notes: 1. All boolean values default to false if not specified 2. The nodes parameter in the machine section defaults to 1 if not specified 3. Even if a vault section is specified, password is optional and should only be supplied for encrypted block vaults 4. Even if vault section is specified, vault objects is optional and applies only to object storage vaults; it indicates which objects should be moved into the environments's backing store for processing. If readonly is set to false, JARVICE automatically copies any new or changed objects from the backing store back to the object storage on normal job completion (but not immediate termination with /jarvice/terminate). 5. ipaddr will be validated by the underlying platform for authorization for the user; it may also fail if the address is already assigned (but this won't be known until the job starts running).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.submit_post(var_json, async_req=True)
        >>> result = thread.get()

        :param var_json: JSON payload to run the compute job, generated as specified above. If copying from the web portal, paste the text into a file or script to use as the JSON payload to submit. Please note that authentication is performed from the username and apikey values in the JSON itself. (required)
        :type var_json: Submission
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, object]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the submit_post_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.submit_post_with_http_info(var_json, **kwargs)  # noqa: E501

    @validate_arguments
    def submit_post_with_http_info(self, var_json : Annotated[Submission, Field(..., description="JSON payload to run the compute job, generated as specified above. If copying from the web portal, paste the text into a file or script to use as the JSON payload to submit. Please note that authentication is performed from the username and apikey values in the JSON itself.")], **kwargs) -> ApiResponse:  # noqa: E501
        """Submits a job for processing.  # noqa: E501

        Submits a job for processing. The body is in JSON format and can be generated from the JARVICE web portal by clicking the PREVIEW SUBMISSION tab in the task builder and copying its contents to the clipboard. Click the copy icon above the SUBMIT button to copy the contents of the API call to the clipboard. NOTE: Adding the identity object in the submission json will replace the NIMBIX Application Environment nimbix user. The JARVICE API cannot override an identity set by an AppDef file. On success, a JSON payload indicating the job name and job number (with name and number keys). Additional Notes: 1. All boolean values default to false if not specified 2. The nodes parameter in the machine section defaults to 1 if not specified 3. Even if a vault section is specified, password is optional and should only be supplied for encrypted block vaults 4. Even if vault section is specified, vault objects is optional and applies only to object storage vaults; it indicates which objects should be moved into the environments's backing store for processing. If readonly is set to false, JARVICE automatically copies any new or changed objects from the backing store back to the object storage on normal job completion (but not immediate termination with /jarvice/terminate). 5. ipaddr will be validated by the underlying platform for authorization for the user; it may also fail if the address is already assigned (but this won't be known until the job starts running).  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.submit_post_with_http_info(var_json, async_req=True)
        >>> result = thread.get()

        :param var_json: JSON payload to run the compute job, generated as specified above. If copying from the web portal, paste the text into a file or script to use as the JSON payload to submit. Please note that authentication is performed from the username and apikey values in the JSON itself. (required)
        :type var_json: Submission
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, object], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'var_json'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method submit_post" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        if _params['var_json'] is not None:
            _body_params = _params['var_json']

        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # set the HTTP header `Content-Type`
        _content_types_list = _params.get('_content_type',
            self.api_client.select_header_content_type(
                ['application/json']))
        if _content_types_list:
                _header_params['Content-Type'] = _content_types_list

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, object]",
            '400': None,
            '401': None,
            '404': None,
            '429': None,
            '500': None,
            '501': None,
        }

        return self.api_client.call_api(
            '/jarvice/submit', 'POST',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))

    @validate_arguments
    def terminate_get(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> Dict[str, object]:  # noqa: E501
        """Immediately terminates a running job. NB: This will terminate the job regardless of current status.  # noqa: E501

        Immediately terminates a running job. NB: This will terminate the job regardless of current status. Best Practice: Use the /jarvice/shutdown for a job in PROCESSING STARTING state and only use /jarvice/terminate for a job not in a PROCESSING STARTING state or not responding to a /jarvice/shutdown. On success: {\"status\": \"terminated\"} A job not in PROCESSING STARTING status will return an error, e.g. {\"error\": \"Running job is not found\"} Notes: One of name or number must be specified  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.terminate_get(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: Dict[str, object]
        """
        kwargs['_return_http_data_only'] = True
        if '_preload_content' in kwargs:
            raise ValueError("Error! Please call the terminate_get_with_http_info method with `_preload_content` instead and obtain raw data from ApiResponse.raw_data")
        return self.terminate_get_with_http_info(apikey, username, name, number, **kwargs)  # noqa: E501

    @validate_arguments
    def terminate_get_with_http_info(self, apikey : Annotated[StrictStr, Field(..., description="API key for user to authenticate")], username : Annotated[StrictStr, Field(..., description="Name of user to authenticate")], name : Annotated[Optional[StrictStr], Field(description="Job name (name key returned from /jarvice/submit *Must be specifed or number is specified")] = None, number : Annotated[Optional[StrictInt], Field(description="Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified")] = None, **kwargs) -> ApiResponse:  # noqa: E501
        """Immediately terminates a running job. NB: This will terminate the job regardless of current status.  # noqa: E501

        Immediately terminates a running job. NB: This will terminate the job regardless of current status. Best Practice: Use the /jarvice/shutdown for a job in PROCESSING STARTING state and only use /jarvice/terminate for a job not in a PROCESSING STARTING state or not responding to a /jarvice/shutdown. On success: {\"status\": \"terminated\"} A job not in PROCESSING STARTING status will return an error, e.g. {\"error\": \"Running job is not found\"} Notes: One of name or number must be specified  # noqa: E501
        This method makes a synchronous HTTP request by default. To make an
        asynchronous HTTP request, please pass async_req=True

        >>> thread = api.terminate_get_with_http_info(apikey, username, name, number, async_req=True)
        >>> result = thread.get()

        :param apikey: API key for user to authenticate (required)
        :type apikey: str
        :param username: Name of user to authenticate (required)
        :type username: str
        :param name: Job name (name key returned from /jarvice/submit *Must be specifed or number is specified
        :type name: str
        :param number: Job number (number key returned from /jarvice/submit) *Must be specifed or name is specified
        :type number: int
        :param async_req: Whether to execute the request asynchronously.
        :type async_req: bool, optional
        :param _preload_content: if False, the ApiResponse.data will
                                 be set to none and raw_data will store the 
                                 HTTP response body without reading/decoding.
                                 Default is True.
        :type _preload_content: bool, optional
        :param _return_http_data_only: response data instead of ApiResponse
                                       object with status code, headers, etc
        :type _return_http_data_only: bool, optional
        :param _request_timeout: timeout setting for this request. If one
                                 number provided, it will be total request
                                 timeout. It can also be a pair (tuple) of
                                 (connection, read) timeouts.
        :param _request_auth: set to override the auth_settings for an a single
                              request; this effectively ignores the authentication
                              in the spec for a single request.
        :type _request_auth: dict, optional
        :type _content_type: string, optional: force content-type for the request
        :return: Returns the result object.
                 If the method is called asynchronously,
                 returns the request thread.
        :rtype: tuple(Dict[str, object], status_code(int), headers(HTTPHeaderDict))
        """

        _params = locals()

        _all_params = [
            'apikey',
            'username',
            'name',
            'number'
        ]
        _all_params.extend(
            [
                'async_req',
                '_return_http_data_only',
                '_preload_content',
                '_request_timeout',
                '_request_auth',
                '_content_type',
                '_headers'
            ]
        )

        # validate the arguments
        for _key, _val in _params['kwargs'].items():
            if _key not in _all_params:
                raise ApiTypeError(
                    "Got an unexpected keyword argument '%s'"
                    " to method terminate_get" % _key
                )
            _params[_key] = _val
        del _params['kwargs']

        _collection_formats = {}

        # process the path parameters
        _path_params = {}

        # process the query parameters
        _query_params = []
        if _params.get('apikey') is not None:  # noqa: E501
            _query_params.append(('apikey', _params['apikey']))

        if _params.get('username') is not None:  # noqa: E501
            _query_params.append(('username', _params['username']))

        if _params.get('name') is not None:  # noqa: E501
            _query_params.append(('name', _params['name']))

        if _params.get('number') is not None:  # noqa: E501
            _query_params.append(('number', _params['number']))

        # process the header parameters
        _header_params = dict(_params.get('_headers', {}))
        # process the form parameters
        _form_params = []
        _files = {}
        # process the body parameter
        _body_params = None
        # set the HTTP header `Accept`
        _header_params['Accept'] = self.api_client.select_header_accept(
            ['*/*'])  # noqa: E501

        # authentication setting
        _auth_settings = []  # noqa: E501

        _response_types_map = {
            '200': "Dict[str, object]",
            '400': "str",
            '401': None,
            '404': "object",
        }

        return self.api_client.call_api(
            '/jarvice/terminate', 'GET',
            _path_params,
            _query_params,
            _header_params,
            body=_body_params,
            post_params=_form_params,
            files=_files,
            response_types_map=_response_types_map,
            auth_settings=_auth_settings,
            async_req=_params.get('async_req'),
            _return_http_data_only=_params.get('_return_http_data_only'),  # noqa: E501
            _preload_content=_params.get('_preload_content', True),
            _request_timeout=_params.get('_request_timeout'),
            collection_formats=_collection_formats,
            _request_auth=_params.get('_request_auth'))
